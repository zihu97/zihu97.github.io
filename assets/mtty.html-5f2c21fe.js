import{_ as e,W as o,X as d,a2 as c}from"./framework-3a0c4e99.js";const t="/assets/image-25-14d019d4.png",i="/assets/image-26-32e85858.png",r="/assets/image-27-478c5aa7.png",a="/assets/image-28-41144843.png",s={},n=c('<h1 id="vfio框架源码分析-五-mdev驱动实现剖析-以mtty示例驱动为蓝本" tabindex="-1"><a class="header-anchor" href="#vfio框架源码分析-五-mdev驱动实现剖析-以mtty示例驱动为蓝本" aria-hidden="true">#</a> VFIO框架源码分析（五）- MDEV驱动实现剖析：以mtty示例驱动为蓝本</h1><h2 id="引言与整体框架" tabindex="-1"><a class="header-anchor" href="#引言与整体框架" aria-hidden="true">#</a> 引言与整体框架</h2><p>在前文对 <code>vfio-mdev</code> 框架的分析中，我们了解到它是一个通用的“胶水层”，负责将任何 <code>mdev</code> (Mediated Device) 虚拟设备适配到 VFIO 体系中。然而，<code>vfio-mdev</code> 自身并不创造虚拟设备，这一职责落在了底层的物理设备驱动身上。<code>mtty</code> (Mediated TTY) 正是内核源码中提供的一个官方示例，它完整地展示了一个物理驱动（尽管它本身也是虚拟的）如何实现 <code>MDEV</code> 接口，从而将其“硬件”资源分割给多个用户。</p><p><code>mtty</code> 模拟了一个可以被虚拟化的多端口 TTY 设备。通过分析其源码，我们可以清晰地理解一个 MDEV 父驱动（Parent Driver）需要承担的全部职责：从向内核注册虚拟化能力，到管理虚拟设备生命周期，再到最终为每个虚拟设备实现具体的 I/O 模拟。</p><p><strong>核心分析：mtty驱动的双重角色</strong></p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>mtty</code> 驱动的初始化函数 <code>mtty_dev_init</code> 揭示了其设计的核心——它同时扮演了两个关键角色：</p><ol><li><p><strong>MDEV父设备驱动</strong>: 通过调用 <code>mdev_register_device</code>，<code>mtty</code> 将自己注册为一个可以被虚拟化的父设备。</p><ul><li>它传递了 <code>mdev_fops</code> 结构体，其中定义了创建和销毁 <code>mdev</code> 实例时的核心回调函数（<code>.probe = mtty_probe</code>）。</li><li>它还定义了 <code>mdev_type_groups</code>，通过 <code>sysfs</code> 向用户空间暴露出它支持创建的 <code>mdev</code> 类型（例如，名为 &quot;1&quot; 和 &quot;2&quot; 的两种类型），以及每种类型的可用实例数量等信息。</li></ul></li><li><p><strong>MDEV设备驱动</strong>: 通过调用 <code>mdev_register_driver</code>，<code>mtty</code> 也注册了一个标准的 <code>device_driver</code>。这个驱动（<code>mtty_driver</code>）的作用是绑定到由 <code>mtty</code> 自己创建的 <code>mdev</code> 虚拟设备上。这是一个自包含的设计，即 <code>mtty</code> 不仅是 <code>mdev</code> 的“生产者”，也是这些 <code>mdev</code> 的“管理者”。</p></li></ol><h2 id="分步详解-一个mtty虚拟设备的生命周期" tabindex="-1"><a class="header-anchor" href="#分步详解-一个mtty虚拟设备的生命周期" aria-hidden="true">#</a> 分步详解：一个mtty虚拟设备的生命周期</h2><h3 id="第一步-mdev实例的创建与探测-mtty-probe" tabindex="-1"><a class="header-anchor" href="#第一步-mdev实例的创建与探测-mtty-probe" aria-hidden="true">#</a> <strong>第一步：MDEV实例的创建与探测 (<code>mtty_probe</code>)</strong></h3><p>当用户通过 <code>sysfs</code> 接口请求创建一个 <code>mtty</code> 类型的 <code>mdev</code> 设备时，MDEV核心框架会调用 <code>mtty_fops</code> 中注册的 <code>.probe</code> 回调函数，即 <code>mtty_probe</code>。此函数是虚拟设备生命周期的起点。</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>资源管理</strong>: <code>mtty_probe</code> 首先会检查父设备是否还有足够资源来创建新的虚拟设备。它以原子方式检查并减少可用端口数 <code>avail_ports</code>，如果资源不足则创建失败。这模拟了真实硬件驱动管理虚拟功能（VF）资源的过程。</li><li><strong>VFIO设备封装</strong>: 资源检查通过后，<code>mtty_probe</code> 会为这个新的 <code>mdev</code> 实例创建一个状态保持结构 (<code>mdev_state</code>)。接着，它调用 <code>vfio_init_group_dev</code> 函数，将这个 <code>mdev</code> 设备封装成一个标准的 <code>vfio_device</code>，并把 <code>mtty_dev_ops</code> 作为其操作函数集。</li><li><strong>设备模拟初始化</strong>: 最后，它调用 <code>mtty_create_config_space</code> 来初始化一块内存，用于模拟该虚拟设备的PCI配置空间，并存放在 <code>mdev_state-&gt;vconfig</code> 中。</li></ul><h3 id="第二步-i-o模拟与vfio接口实现-mtty-dev-ops" tabindex="-1"><a class="header-anchor" href="#第二步-i-o模拟与vfio接口实现-mtty-dev-ops" aria-hidden="true">#</a> <strong>第二步：I/O模拟与VFIO接口实现 (<code>mtty_dev_ops</code>)</strong></h3><p>一旦 <code>mdev</code> 被封装成 <code>vfio_device</code> 并传递给用户空间（如QEMU），用户空间便会通过标准的VFIO接口（<code>read</code>, <code>write</code>, <code>ioctl</code>）与其交互。这些操作最终都由 <code>mtty_dev_ops</code> 中的函数来处理，从而实现了设备行为的完整模拟。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong><code>read</code>/<code>write</code> 操作</strong>: 由 <code>mtty_read</code> 和 <code>mtty_write</code> 函数处理。 <ul><li>当访问 <code>VFIO_PCI_CONFIG_REGION_INDEX</code> 时，驱动直接对 <code>mdev_state-&gt;vconfig</code> 这块内存进行读写。这向用户空间提供了一个完全虚拟的、行为一致的PCI配置空间。</li><li>当访问 <code>VFIO_PCI_BARx_REGION_INDEX</code> 时，驱动通过 <code>handle_bar_read/write</code> 函数，读写 <code>mdev_state</code> 中的另一块模拟内存区域（<code>mdev_state-&gt;s[index]</code>）。这模拟了对设备MMIO Bar空间的访问。</li></ul></li></ul><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong><code>ioctl</code> 操作</strong>: 由 <code>mtty_ioctl</code> 函数处理。它实现了如 <code>VFIO_DEVICE_GET_INFO</code> 等一系列标准的VFIO <code>ioctl</code> 命令，向用户空间报告这个模拟设备的各种元数据（Region信息、中断信息等），使其看起来和一个真实的PCI设备别无二致。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><code>mtty</code> 驱动以一个简洁而完整的方式，为我们提供了一个实现 MDEV 父驱动的完美范例。它清晰地展示了成为一个合格的 MDEV 父驱动所需的核心要素：</p><ol><li><strong>能力注册</strong>: 必须通过 <code>mdev_register_device</code> 向 MDEV 核心注册自己，并定义可供创建的虚拟设备类型。</li><li><strong>生命周期管理</strong>: 必须实现 <code>.probe</code> 和 <code>.remove</code> 等回调函数，在其中处理虚拟设备的创建和销毁，包括关键的父设备资源管理。</li><li><strong>VFIO接口适配</strong>: 必须为创建的 <code>mdev</code> 实例提供一套 <code>vfio_device_ops</code> 实现，将VFIO的标准化操作（如访问配置空间、BAR空间）转化为对内部模拟状态的读写。</li><li><strong>状态虚拟化</strong>: 必须为每个 <code>mdev</code> 实例维护一个独立的状态（<code>mdev_state</code>），包含了模拟设备所需的所有信息，如虚拟配置空间、虚拟BAR区等，从而实现多实例间的隔离。</li></ol><p><code>mtty</code> 的存在，极大地降低了硬件厂商开发支持 SR-IOV 或其他类型设备共享技术的驱动的门槛，它是一个功能完备、可供参考和模仿的“活文档”。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p>大家好，我是宝爷，浙大本科、前华为工程师、现某芯片公司系统架构负责人，关注个人成长。</p><p>新的图解文章都在公众号「宝爷说」首发，别忘记关注了哦！</p><p>感谢你读到这里。</p><p>如果这篇文章对您有所帮助，欢迎点赞、分享或收藏！你的支持是我创作的动力！</p><p>如果您不想错过未来的更新，记得点个星标 ⭐，下次我更新你就能第一时间收到推送啦。</p>',29),m=[n];function _(l,p){return o(),d("div",null,m)}const v=e(s,[["render",_],["__file","mtty.html.vue"]]);export{v as default};
