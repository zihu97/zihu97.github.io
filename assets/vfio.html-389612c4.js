import{_ as o,W as e,X as i,a2 as d}from"./framework-3a0c4e99.js";const c="/assets/image-174e5f05.png",n="/assets/image-1-454aad50.png",r="/assets/image-2-d412fedf.png",t="/assets/image-3-4f52176f.png",a="/assets/image-4-a3411807.png",s="/assets/image-5-56efb81f.png",p="/assets/image-6-863abb50.png",g={},f=d('<h1 id="vfio框架源码分析-一-从初始化到设备访问" tabindex="-1"><a class="header-anchor" href="#vfio框架源码分析-一-从初始化到设备访问" aria-hidden="true">#</a> VFIO框架源码分析（一）- 从初始化到设备访问</h1><h2 id="引言与整体框架" tabindex="-1"><a class="header-anchor" href="#引言与整体框架" aria-hidden="true">#</a> 引言与整体框架</h2><p>VFIO (Virtual Function I/O) 是Linux内核中一个健壮、安全的用户空间驱动框架。它允许将物理设备（特别是PCI设备）安全地、非特权地“直通”给用户空间应用程序，最典型的应用场景就是QEMU/KVM虚拟机监视器（VMM）将宿主机的PCI/PCIe设备（如GPU、网卡）直接分配给虚拟机使用。VFIO的核心是利用IOMMU（Input-Output Memory Management Unit）提供的DMA地址隔离和中断重映射能力，确保用户空间的设备访问不会威胁到系统其他部分的安全。</p><p>本文将基于linux v5.15版本，深入剖析其从内核模块初始化到用户空间获取最终设备文件描述符（FD）的全过程。</p><p><strong>核心分析：<code>vfio_init</code> 模块入口</strong></p><p>与所有内核模块一样，VFIO的生命周期始于其初始化函数 <code>vfio_init</code>。此函数是整个VFIO框架的基石，主要完成两项关键的字符设备注册工作：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p><strong>注册 <code>/dev/vfio/vfio</code> (Container) 设备</strong>: 通过 <code>misc_register(&amp;vfio_dev)</code> 函数注册一个混杂设备（misc device）。这个设备对应于用户空间路径 <code>/dev/vfio/vfio</code>。打开此设备将得到一个代表 <strong>VFIO Container</strong> 的文件描述符。一个Container可以理解为一个隔离的IOMMU域，通常代表一个虚拟机（VM）的内存保护上下文。所有要分配给该VM的设备组（Group）都必须关联到这个Container上。该设备的操作函数集由 <code>vfio_fops</code> 定义。</p></li><li><p><strong>注册Group设备号</strong>: 通过 <code>alloc_chrdev_region</code> 和 <code>cdev_init</code> 函数，为 <strong>VFIO Group</strong> 动态分配一个主设备号，并初始化其字符设备结构。内核中的每个IOMMU Group都会对应一个设备文件，例如 <code>/dev/vfio/1</code>, <code>/dev/vfio/2</code> 等。这些设备文件的操作由 <code>vfio_group_fops</code> 定义。</p></li></ol><h2 id="分步详解-从container到device的层次化访问" tabindex="-1"><a class="header-anchor" href="#分步详解-从container到device的层次化访问" aria-hidden="true">#</a> 分步详解：从Container到Device的层次化访问</h2><p>VFIO的设计哲学是层次化的，用户空间必须按顺序创建和关联Container、Group和Device，最终才能访问到物理设备。</p><h4 id="第一层-vfio-container的创建与配置" tabindex="-1"><a class="header-anchor" href="#第一层-vfio-container的创建与配置" aria-hidden="true">#</a> <strong>第一层：VFIO Container的创建与配置</strong></h4><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用户空间的第一步是打开 <code>/dev/vfio/vfio</code> 文件，获取一个Container文件描述符（fd）。这个fd是后续所有操作的句柄。对这个fd的核心操作是通过 <code>ioctl</code> 系统调用完成的，其在内核中由 <code>vfio_fops_unl_ioctl</code> 函数处理。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong><code>VFIO_GET_API_VERSION</code></strong>: 用于查询VFIO的API版本号。</li><li><strong><code>VFIO_CHECK_EXTENSION</code></strong>: 用于检查内核是否支持特定的IOMMU后端类型，例如 <code>VFIO_TYPE1_IOMMU</code>。</li><li><strong><code>VFIO_SET_IOMMU</code></strong>: 这是最关键的操作之一。用户空间通过此 <code>ioctl</code> 告知VFIO要使用哪种IOMMU后端。内核侧的 <code>vfio_ioctl_set_iommu</code> 函数会遍历已注册的IOMMU驱动列表（<code>vfio.iommu_drivers_list</code>），找到匹配的驱动并将其操作函数集（<code>driver-&gt;ops</code>）附加到Container上。自此，Container便具备了管理IOMMU页表的能力。</li></ul><h4 id="第二层-vfio-group与container的关联" tabindex="-1"><a class="header-anchor" href="#第二层-vfio-group与container的关联" aria-hidden="true">#</a> <strong>第二层：VFIO Group与Container的关联</strong></h4><p>当Container准备就绪后，下一步是处理IOMMU Group。一个Group是IOMMU能够进行隔离的最小设备单元。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用户空间打开代表特定Group的设备文件（例如 <code>/dev/vfio/1</code>），获得一个Group fd。同样，关键操作也是通过 <code>ioctl</code> 进行，由 <code>vfio_group_fops_unl_ioctl</code> 函数处理。</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong><code>VFIO_GROUP_GET_STATUS</code></strong>: 获取Group的状态，例如它是否可行（viable）。</li><li><strong><code>VFIO_GROUP_SET_CONTAINER</code></strong>: 这是连接两层的桥梁。用户空间将第一步中获得的Container fd作为参数传递给此<code>ioctl</code>。内核中的 <code>vfio_group_set_container</code> 函数会将当前的Group结构体关联到指定的Container上（通过 <code>list_add</code> 操作加入到Container的group链表中）。只有关联到Container后，Group内的设备才能使用Container所管理的IOMMU域进行DMA映射。</li></ul><h4 id="第三层-获取device-fd与最终设备访问" tabindex="-1"><a class="header-anchor" href="#第三层-获取device-fd与最终设备访问" aria-hidden="true">#</a> <strong>第三层：获取Device FD与最终设备访问</strong></h4><p>当Group成功关联到Container后，用户空间就可以获取Group内具体设备的控制权了。</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong><code>VFIO_GROUP_GET_DEVICE_FD</code></strong>: 用户空间通过此<code>ioctl</code>并提供设备名称（如 &quot;0000:01:00.0&quot;）来请求获取一个代表物理设备的文件描述符。 <ul><li>内核中的 <code>vfio_group_get_device_fd</code> 函数首先通过 <code>vfio_device_get_from_name</code> 找到对应的 <code>vfio_device</code> 结构体。</li><li>然后，它调用 <code>anon_inode_getfile</code> 创建一个与物理设备关联的匿名文件描述符，这个新的fd的操作函数集由 <code>vfio_device_fops</code> 定义。</li></ul></li></ul><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个最终获得的Device fd是用户空间直接与硬件交互的句柄。对它进行 <code>read</code>, <code>write</code>, <code>mmap</code>, <code>ioctl</code> 等操作，会通过 <code>vfio_device_fops</code> 最终调用到底层的、与具体总线相关的VFIO驱动（如 <code>vfio-pci</code>）所实现的操作函数（<code>device-&gt;ops</code>），从而操作设备的配置空间、MMIO/PIO区域等。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>通过分析，我们可以清晰地梳理出VFIO的工作流程和核心设计思想：</p><ol><li><strong>模块初始化 (<code>vfio_init</code>)</strong>: 创建了两种核心的字符设备接口，分别用于管理Container和Group。</li><li><strong>Container层</strong>: 用户空间通过操作 <code>/dev/vfio/vfio</code> 创建一个IOMMU域（Container），并为其绑定一个IOMMU后端驱动。</li><li><strong>Group层</strong>: 用户空间打开代表IOMMU Group的 <code>/dev/vfio/$GROUP</code> 文件，并将其附加到已经创建好的Container上，从而使Group内的设备受该Container的IOMMU域保护。</li><li><strong>Device层</strong>: 最后，从Group中获取代表具体设备的fd。这个fd是用户空间驱动程序的最终目标，通过它可以对设备进行内存映射（<code>mmap</code>）和寄存器读写，实现设备的完全控制。</li></ol><p>VFIO通过这种Container -&gt; Group -&gt; Device的逐层授权和关联机制，构建了一个安全、隔离的用户空间设备访问模型，是现代虚拟化技术不可或缺的一环。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p>大家好，我是宝爷，浙大本科、前华为工程师、现某芯片公司系统架构负责人，关注个人成长。</p><p>新的图解文章都在公众号「宝爷说」首发，别忘记关注了哦！</p><p>感谢你读到这里。</p><p>如果这篇文章对您有所帮助，欢迎点赞、分享或收藏！你的支持是我创作的动力！</p><p>如果您不想错过未来的更新，记得点个星标 ⭐，下次我更新你就能第一时间收到推送啦。</p>',37),l=[f];function _(u,v){return e(),i("div",null,l)}const I=o(g,[["render",_],["__file","vfio.html.vue"]]);export{I as default};
