import{_ as i,W as e,X as a,a2 as r}from"./framework-3a0c4e99.js";const o="/assets/image-5af1466a.png",t="/assets/image-1-3f4f89d1.png",n="/assets/image-2-3743fbc5.png",s="/assets/image-3-83a89361.png",g={},d=r('<h1 id="vfio框架源码分析-十一-qemu-vfio-实时迁移-live-migration-架构深度解析" tabindex="-1"><a class="header-anchor" href="#vfio框架源码分析-十一-qemu-vfio-实时迁移-live-migration-架构深度解析" aria-hidden="true">#</a> VFIO框架源码分析（十一）- QEMU VFIO 实时迁移 (Live Migration) 架构深度解析</h1><h2 id="一、-背景与核心挑战" tabindex="-1"><a class="header-anchor" href="#一、-背景与核心挑战" aria-hidden="true">#</a> 一、 背景与核心挑战</h2><p>在虚拟化场景下，设备的<strong>实时迁移 (Live Migration)</strong> 一直是“直通设备 (Passthrough Device)”的阿喀琉斯之踵。</p><ul><li><p><strong>纯模拟设备 (Virtio)</strong>：状态完全在内存中（QEMU 进程内），迁移就是简单的内存拷贝。</p></li><li><p><strong>直通设备 (VFIO)</strong>：设备状态散落在硬件内部的寄存器、SRAM、甚至是正在处理的 Pipeline 中。对 Hypervisor (QEMU) 来说，这是一个<strong>黑盒</strong>。</p></li></ul><p>随着云原生架构对弹性伸缩的需求，Linux 内核与 QEMU 引入了 VFIO Migration 协议。其核心思想是：<strong>打破黑盒，定义标准 ABI，让硬件驱动（Vendor Driver）主动将内部状态“序列化”为字节流，通过 QEMU 搬运到目标机，再“反序列化”恢复。</strong></p><p>本文基于 QEMU 源码与 Linux VFIO Migration v2 协议（Linux 6.0+），深度解析这一过程。</p><h2 id="二、-核心架构-控制流与数据流" tabindex="-1"><a class="header-anchor" href="#二、-核心架构-控制流与数据流" aria-hidden="true">#</a> 二、 核心架构：控制流与数据流</h2><p>VFIO 迁移架构并非单纯的代码逻辑，而是一套严格的 <strong>State Machine（状态机）</strong> 和 <strong>Data Pipeline（数据管道）</strong>。</p><p>核心结构体定义在 <code>hw/vfio/migration.c</code> 和内核头文件 <code>include/uapi/linux/vfio.h</code> 中。</p><h3 id="_1-控制面-状态机-state-machine" tabindex="-1"><a class="header-anchor" href="#_1-控制面-状态机-state-machine" aria-hidden="true">#</a> 1. 控制面：状态机 (State Machine)</h3><p>QEMU 不懂硬件细节，它只负责通过 <code>ioctl(VFIO_DEVICE_FEATURE)</code> 控制设备的状态流转。在 v2 协议中，主要状态包括：</p><ul><li><strong>RUNNING</strong>: 设备正常工作，DMA 开启。</li><li><strong>PRE_COPY</strong>: 设备在运行，但驱动开始导出内部状态（迭代阶段）。</li><li><strong>STOP_COPY</strong>: 设备停止运行（DMA 暂停），驱动导出剩余的所有状态。</li><li><strong>RESUMING</strong>: 目标机设备处于接收数据并恢复现场的状态。</li></ul><h3 id="_2-数据面-迁移缓冲区-migration-region" tabindex="-1"><a class="header-anchor" href="#_2-数据面-迁移缓冲区-migration-region" aria-hidden="true">#</a> 2. 数据面：迁移缓冲区 (Migration Region)</h3><p>这是 QEMU 与内核驱动交换数据的“窗口”。设备驱动在 BAR 空间或特定的 PCI Capability 中暴露一块 <strong>Migration Region</strong>。</p><ul><li><strong>Device -&gt; QEMU</strong>: 驱动将硬件状态 dump 到这个 Region，QEMU 像读文件一样读走。</li><li><strong>QEMU -&gt; Device</strong>: QEMU 将数据写入 Region，驱动读取并恢复硬件。</li></ul><h2 id="三、-逐层代码拆解与生命周期分析" tabindex="-1"><a class="header-anchor" href="#三、-逐层代码拆解与生命周期分析" aria-hidden="true">#</a> 三、 逐层代码拆解与生命周期分析</h2><p>我们将代码逻辑按照迁移的生命周期重新串联：<strong>初始化 -&gt; 迭代传输 -&gt; 停机切换 -&gt; 恢复</strong>。</p><h3 id="_1-迁移初始化-vfio-migration-realize" tabindex="-1"><a class="header-anchor" href="#_1-迁移初始化-vfio-migration-realize" aria-hidden="true">#</a> 1. 迁移初始化：<code>vfio_migration_realize</code></h3><p>这是迁移能力的探测阶段。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>关键点</strong>：这里建立了 Userspace 和 Kernel 的共享内存通道。为了 SOTA 性能，这里通常采用 mmap 方式，避免数据搬运时的上下文切换。</p><h3 id="_2-开启脏页追踪-memory-dirty-tracking" tabindex="-1"><a class="header-anchor" href="#_2-开启脏页追踪-memory-dirty-tracking" aria-hidden="true">#</a> 2. 开启脏页追踪：Memory Dirty Tracking</h3><p>迁移不仅要迁设备内部状态，还要迁设备 DMA 写入的系统内存。如果迁移过程中设备还在疯狂写内存，必须记录下来重传。</p><ul><li><strong>QEMU 动作</strong>: 调用 <code>vfio_memory_listener</code> 相关的 log_start。</li><li><strong>内核/硬件动作</strong>: <ul><li><strong>IOMMU 硬件追踪</strong> (Modern): 利用 IOMMU 的 Dirty Bit 功能，性能开销极小。</li><li><strong>软件追踪</strong> (Legacy): 驱动强制将 IOVA 设为只读，触发 IOMMU Page Fault 来捕获写操作（性能较差）。</li></ul></li><li><strong>交互</strong>: 在迭代阶段，QEMU 定期调用 <code>ioctl(VFIO_IOMMU_DIRTY_PAGES)</code> 或查询 <code>IOMMUFD</code> 获取位图。</li></ul><h3 id="_3-迭代传输阶段-vfio-save-iterate-pre-copy" tabindex="-1"><a class="header-anchor" href="#_3-迭代传输阶段-vfio-save-iterate-pre-copy" aria-hidden="true">#</a> 3. 迭代传输阶段：<code>vfio_save_iterate</code> (Pre-Copy)</h3><p>这是虚拟机仍在运行时的“热传输”阶段。目标是尽可能把静态数据先搬过去，减小最后停机的时间窗口。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>开发者视角</strong>：在这个阶段，AI 芯片驱动应该利用硬件的空闲时间（Overlap）整理状态，尽量不要阻塞主要的推理任务。</p><h3 id="_4-停机与最终传输-vfio-save-complete-precopy-stop-and-copy" tabindex="-1"><a class="header-anchor" href="#_4-停机与最终传输-vfio-save-complete-precopy-stop-and-copy" aria-hidden="true">#</a> 4. 停机与最终传输：<code>vfio_save_complete_precopy</code> (Stop-and-Copy)</h3><p>这是迁移最关键的时刻，虚拟机 CPU 停止运行。</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-目标端恢复-vfio-load-state" tabindex="-1"><a class="header-anchor" href="#_5-目标端恢复-vfio-load-state" aria-hidden="true">#</a> 5. 目标端恢复：<code>vfio_load_state</code></h3><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>目标机接收数据流，就像“回放”录像一样。</p><ul><li><strong>写入数据</strong>: QEMU 循环读取迁移流，写入目标设备的 Migration Region。</li><li><strong>驱动处理</strong>: 驱动收到数据后，解析并恢复硬件内部状态。</li><li><strong>最终激活</strong>: 当所有数据加载完毕，QEMU 将设备状态切换为 <strong>RESUMING -&gt; RUNNING</strong>。设备复活，继续执行中断的推理任务。</li></ul><h2 id="四、-深度总结与技术演进" tabindex="-1"><a class="header-anchor" href="#四、-深度总结与技术演进" aria-hidden="true">#</a> 四、 深度总结与技术演进</h2><p>VFIO 迁移框架的本质是将<strong>硬件状态软件化</strong>。</p><h3 id="_1-架构优势" tabindex="-1"><a class="header-anchor" href="#_1-架构优势" aria-hidden="true">#</a> 1. 架构优势</h3><ul><li><strong>解耦</strong>: QEMU 不需要知道设备是 GPU 还是网卡，它只负责搬运 &quot;Data Blob&quot;。</li><li><strong>一致性</strong>: 结合 IOMMU 脏页追踪，保证了 DMA 和 CPU 内存的一致性。</li></ul><h3 id="_2-未来的演进-linux-6-6-ai-chip" tabindex="-1"><a class="header-anchor" href="#_2-未来的演进-linux-6-6-ai-chip" aria-hidden="true">#</a> 2. 未来的演进 (Linux 6.6+ &amp; AI Chip)</h3><p>对于高性能 AI 芯片，当前的挑战在于<strong>状态量巨大</strong>（GB 级别的 HBM 上下文）。</p><ul><li><p><strong>P2P Migration</strong>: 未来方向是绕过 QEMU CPU 拷贝，直接通过 RDMA 将源端显存搬运到目标端显存（Offloading）。</p></li><li><p><strong>IOMMUFD</strong>: Linux 6.6 引入的 <code>iommufd</code> 子系统进一步优化了脏页追踪的性能，支持硬件加速的位图上报。</p></li><li><p><strong>Switchdev 模式</strong>: 支持 SR-IOV 的 VF 在 Hypervisor 不感知的情况下，通过 PF 驱动进行热迁移。</p></li></ul><p>对于驱动开发者而言，实现高效的 <code>save_live_iterate</code> 回调，在不影响 GPU 推理性能的前提下，利用 DMA 引擎并行导出状态，是达到 SOTA 迁移性能的关键。</p><h2 id="关于作者" tabindex="-1"><a class="header-anchor" href="#关于作者" aria-hidden="true">#</a> 关于作者</h2><p>大家好，我是宝爷，浙大本科、前华为工程师、现某芯片公司系统架构负责人，关注个人成长。</p><p>新的图解文章都在公众号「宝爷说」首发，别忘记关注了哦！</p><p>感谢你读到这里。</p><p>如果这篇文章对您有所帮助，欢迎点赞、分享或收藏！你的支持是我创作的动力！</p><p>如果您不想错过未来的更新，记得点个星标 ⭐，下次我更新你就能第一时间收到推送啦。</p>',49),l=[d];function c(p,h){return e(),a("div",null,l)}const _=i(g,[["render",c],["__file","Live Migration.html.vue"]]);export{_ as default};
